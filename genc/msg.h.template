@###############################################
@#
@# ROS message source code generation for C++
@#
@# EmPy template for generating <msg>.h files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@###############################################
/* Software License Agreement (BSD License)
 *
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Willow Garage, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Auto-generated by genmsg_c from file @file_name_in
 *
 */

@{
import genmsg.msgs
import gencpp
import genmsg.msg_loader

cpp_msg_definition = gencpp.escape_message_definition(msg_definition)
}@

#ifndef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H
#define @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H

//#############################
// Generic Includes
//#############################


//#############################
// Includes for dependencies
//#############################
@{
for field in spec.parsed_fields():
  if (not field.is_builtin):
    if (field.is_header):
      print '#include <std_msgs/Header.h>'
    else:
      (package, name) = genmsg.names.package_resource_name(field.base_type)
      package = package or spec.package # convert '' to package
      print '#include <rosc/msg/%s/%s.h>'%(package, name)
}@


//Constants
@[for constant in spec.constants]@
 @[if (constant.type in ['byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64'])]@
   enum { @(constant.name) = @(int(constant.val)) };
 @[else]@
   static const @(gencpp.msg_type_to_cpp(constant.type)) @(constant.name);
 @[end if]@
@[end for]


//Constants2
@[for c in spec.constants]
   @[if c.type not in ['byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64']]
   template<typename ContainerAllocator> const @(gencpp.msg_type_to_cpp(c.type))
      @(spec.short_name)_<ContainerAllocator>::@(c.name) =
        @[if c.type == 'string']
          "@(gencpp.escape_string(c.val))"'byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64', 'string', 'bool', 'float64', 'float32', 'time', 'duration'
        @[elif c.type == 'bool']
           @(int(c.val))
        @[else]
          @c.val
        @[end if]
        ;
   @[end if]
@[end for]






// Spec.package
@(spec.package)

// Message Traits

// String traits
@[for trait_class,trait_value in [['MD5Sum', md5sum], ['DataType', spec.full_name], ['Definition', cpp_msg_definition]]]@
@(trait_class)

@(trait_value)

@{
if trait_class == 'MD5Sum':
  iter_count = len(trait_value) / 16
  for i in xrange(0, iter_count):
    start = i*16
    print '  static const uint64_t static_value%s = 0x%sULL;'%((i+1), trait_value[start:start+16])
}@
@[end for]@

 
ros_msg_buildup_type_t ros_msg_buildup_@(spec.package)[]=
{
@{
def add_tabs(count):
    tabs=""
    for i in range(count):
        tabs = tabs + "\t"
    return tabs

def add_base_type_static(depth, base_type, name):

    if field.base_type in ['uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', 'uint64', 'int64', 'float32', 'float64']:
        return add_tabs(depth) + field.base_type + "_t"
    elif field.base_type == 'byte':
        return add_tabs(depth) + 'uint8_t'
    elif field.base_type == 'char':
        return add_tabs(depth) + 'int8_t'
    elif field.base_type == 'time' or  field.base_type == 'duration':
        output= add_tabs(depth) + struct + '\n'
        output= add_tabs(depth) + '{' + '\n'
        output= add_tabs(depth+1) + '' + '\n'
        output= add_tabs(depth+1) + '' + '\n'
        output= add_tabs(depth) + '}' + name + ';\n'

    
def add_base_array_static(depth, base_type, name, arraylength):
    for line in range(6):
    
        identation=depth
        
        if line in [2,3,4]:
            indentation+=1
            
        for indent in range(indentation):
            str+="/t"
        if line == 0:
            str+="struct"
        elif line == 1:
            str+="{"
        elif line == 2:
            str+=add_base_type(indentation, base_type)
        elif line == 3:
            str+="uint32_t size;"
        elif line == 4:
            str+="bool oversize;"
        elif line == 5:
            str+= "}" + name + ";"
        str+="\n"
    return str;
    
def getInnnerSpec(spec):
    (package, name) = genmsg.names.package_resource_name(field.base_type)
    msg_context = genmsg.msg_loader.MsgContext()
    return genmsg.msg_loader.load_msg_by_type(msg_context, field.base_type, search_path)

def create_buildup_list(depth, spec, array_depth, max_array_depth, fieldname):
    list=""
    struct_static=""
    struct_malloc=""
    max_array_depth=0;
    for field in spec.parsed_fields():
        if field.base_type not in ['byte','char','bool','uint8','int8','uint16','int16','uint32','int32','uint64','int64','float32','float64','string','time','duration']:
            list+=add_tabs(depth)
        
            innerSpec = getInnnerSpec(spec)
                
            list+="ROS_MSG_BUILDUP_TYPE_SUBMESSAGE"
            if (field.is_array):
                list+="ARRAY"
                if(field.array_len == None):
                    list+='_UL'
                array_depth+=1
                if (array_depth+1 > max_array_depth):
                    max_array_depth+=1
            list+=",\n"
            (tlist, max_array_depth)=create_buildup_list(depth+1, innerSpec, array_depth, max_array_depth, fieldname + "_" + field.name)      
            list+=tlist;
            if(field.is_array):
                array_depth-=1
        else:
            if(field.is_array):
                list+=add_tabs(depth)
                list+="ROS_MSG_BUILDUP_TYPE_ARRAY"
                if(field.array_len == None):
                    list+='_UL'
                list+=",\n"

                if(field.base_type == 'string'): #Stringarray ...
                    if (array_depth+2 > max_array_depth):
                        max_array_depth=array_depth+2
                else:
                    if (array_depth+1 > max_array_depth):
                        max_array_depth=array_depth+1
                list+=add_tabs(1) #1 tab more for the data inside array
                                       
            if(field.base_type == 'string'):#String type, which is actually a array itself
                if (array_depth+1 > max_array_depth):
                    max_array_depth=array_depth+1
            list+=add_tabs(depth)
            list+="ROS_MSG_BUILDUP_TYPE_" + field.base_type.upper() +",\n\n"
    list+=add_tabs(depth)
    list+="ROS_MSG_BUILDUP_TYPE_MESSAGE_END,"
    if not depth == 1:
         list+="\n\n"
    return list, max_array_depth


(list,max_array_depth)=create_buildup_list(1,spec,0,0,"")
print list
print msg_context
print field.base_type
print search_path
}@}


#endif // @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H
@(max_array_depth)