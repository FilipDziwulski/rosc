@###############################################
@#
@# ROS message source code generation for C++
@#
@# EmPy template for generating <msg>.h files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@###############################################
/* Software License Agreement (BSD License)
 *
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Willow Garage, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Auto-generated by genmsg_c from file @file_name_in
 *
 */

@{
import genmsg.msgs
import gencpp
import genmsg.msg_loader

cpp_msg_definition = gencpp.escape_message_definition(msg_definition)
}@

#ifndef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H
#define @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H

//#############################
// Generic Includes
//#############################


//#############################
// Includes for dependencies
//#############################
@{
for field in spec.parsed_fields():
  if (not field.is_builtin):
    if (field.is_header):
      print '#include <std_msgs/Header.h>'
    else:
      (package, name) = genmsg.names.package_resource_name(field.base_type)
      package = package or spec.package # convert '' to package
      print '#include <rosc/msg/%s/%s.h>'%(package, name)
}@


//Constants
@[for constant in spec.constants]@
 @[if (constant.type in ['byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64'])]@
   enum { @(constant.name) = @(int(constant.val)) };
 @[else]@
   static const @(gencpp.msg_type_to_cpp(constant.type)) @(constant.name);
 @[end if]@
@[end for]


//Constants2
@[for c in spec.constants]
   @[if c.type not in ['byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64']]
   template<typename ContainerAllocator> const @(gencpp.msg_type_to_cpp(c.type))
      @(spec.short_name)_<ContainerAllocator>::@(c.name) =
        @[if c.type == 'string']
          "@(gencpp.escape_string(c.val))"'byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64', 'string', 'bool', 'float64', 'float32', 'time', 'duration'
        @[elif c.type == 'bool']
           @(int(c.val))
        @[else]
          @c.val
        @[end if]
        ;
   @[end if]
@[end for]






// Spec.package
@(spec.package)

// Message Traits

// String traits
@[for trait_class,trait_value in [['MD5Sum', md5sum], ['DataType', spec.full_name], ['Definition', cpp_msg_definition]]]@
@(trait_class)

@(trait_value)

@{
if trait_class == 'MD5Sum':
  iter_count = len(trait_value) / 16
  for i in xrange(0, iter_count):
    start = i*16
    print '  static const uint64_t static_value%s = 0x%sULL;'%((i+1), trait_value[start:start+16])
}@
@[end for]@

 
ros_msg_buildup_type_t ros_msg_buildup_@(spec.package)[]=
{
@{
def add_tabs(count, str):
    for i in range(count):
        str = str + "\t"
    return str
    
def create_buildup_list(depth, spec, array_depth, max_array_depth):
    list=""
    max_array_depth=0;
    for field in spec.parsed_fields():
        if field.base_type not in ['byte','char','bool','uint8','int8','uint16','int16','uint32','int32','uint64','int64','float32','float64','string','time','duration']:
            list=add_tabs(depth, list)
            (package, name) = genmsg.names.package_resource_name(field.base_type)
            msg_context = genmsg.msg_loader.MsgContext()
            innerSpec = genmsg.msg_loader.load_msg_by_type(msg_context, field.base_type, search_path)
            list=list + "ROS_MSG_BUILDUP_TYPE_SUBMESSAGE"
            if (field.is_array):
                list=list + "ARRAY"
                array_depth+=1
                if (array_depth+1 > max_array_depth):
                    max_array_depth+=1
            list=list + ",\n"
            (tlist, max_array_depth)=create_buildup_list(depth+1, innerSpec, array_depth, max_array_depth)      
            list+=tlist;
            if(field.is_array):
                array_depth-=1
        else:
            if(field.is_array):
                list=add_tabs(depth, list)
                list=list + "ROS_MSG_BUILDUP_TYPE_ARRAY,\n"
                if (array_depth+1 > max_array_depth):
                    max_array_depth+=1
            list=add_tabs(depth, list)
            list=list + "ROS_MSG_BUILDUP_TYPE_" + field.base_type.upper() +",\n"
    list=add_tabs(depth, list)
    list=list + "ROS_MSG_BUILDUP_TYPE_MESSAGE_END,"
    if not depth == 1:
         list=list + "\n"
    return list, max_array_depth


(list,max_array_depth)=create_buildup_list(1,spec,0,0)
print list


}@}

#endif // @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H
@(max_array_depth)